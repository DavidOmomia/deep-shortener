import * as slugsService from '../../slugsService';
import { SlugRepository } from '../../slugsRepository';
import { generateSlug } from '../../slugGenerationService';
import { isValidUrl, normalizeUrl, UnprocessableEntityError, env} from '../../../../utils';

jest.mock('../../slugsRepository');
jest.mock('../../slugGenerationService');

jest.mock('../../../../utils/logger', () => ({
  logger: {
    error: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  },
}));

jest.mock('../../../../utils', () => ({
  ...jest.requireActual('../../../../utils'),
  env: jest.fn((key: string) => {
    switch (key) {
      case 'APP_FRONTEND_NOT_FOUND_URL':
        return 'https://example.com/not-found';
      case 'BASE_URL':
        return 'https://short.ly';
      case 'JWT_SECRET':
        return 'mocked-secret';
      default:
        return undefined;
    }
  }),
}));

const mockUser = {
  id: '12345',
  email: 'test@example.com',
  password: 'hashedpassword',
  createdAt: new Date(),
  updatedAt: new Date(),
};

describe('slugsService', () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createShortenedUrl', () => {
    it('should generate a slug automatically when no slug is provided', async () => {
      const params = { url: 'https://example.com', user: mockUser };
      const normalizedUrl = 'https://example.com/';
      const generatedSlug = 'autogeneratedslug';
      const createdSlug = { id: '1', slug: generatedSlug, url: normalizedUrl, userId: mockUser.id };
 
      (generateSlug as jest.Mock).mockResolvedValue(generatedSlug);
      (SlugRepository.createSlug as jest.Mock).mockResolvedValue(createdSlug);
  
      const result = await slugsService.createShortenedUrl(params);

      expect(generateSlug).toHaveBeenCalled();
      expect(SlugRepository.createSlug).toHaveBeenCalledWith(generatedSlug, normalizedUrl, mockUser.id);
      expect(result).toEqual(createdSlug);
    });

    it('should throw an error if the slug already exists', async () => {
      const params = { url: 'https://example.com', user: mockUser, slug: 'shortslug' };

      (SlugRepository.findSlugBySlug as jest.Mock).mockResolvedValue({ slug: 'shortslug' });

      await expect(slugsService.createShortenedUrl(params)).rejects.toThrow(UnprocessableEntityError);
      expect(SlugRepository.findSlugBySlug).toHaveBeenCalledWith('shortslug');
    });
  });

  describe('getOriginalUrl', () => {
    it('should return the original URL and increment visits', async () => {
      const params = { slug: 'shortslug' };
      const slugRecord = { url: 'https://example.com' };

      (SlugRepository.findSlugBySlug as jest.Mock).mockResolvedValue(slugRecord);
      (SlugRepository.incrementVisits as jest.Mock).mockResolvedValue(undefined);

      const result = await slugsService.getOriginalUrl(params);

      expect(SlugRepository.findSlugBySlug).toHaveBeenCalledWith('shortslug');
      expect(SlugRepository.incrementVisits).toHaveBeenCalledWith('shortslug');
      expect(result).toEqual(slugRecord.url);
    });

    it('should return the not found URL if slug does not exist', async () => {
      const params = { slug: 'nonexistentslug' };
      (SlugRepository.findSlugBySlug as jest.Mock).mockResolvedValue(null);

      const notFoundUrl = `${env("APP_FRONTEND_NOT_FOUND_URL")}?url=${env("BASE_URL")}/nonexistentslug`;
      const result = await slugsService.getOriginalUrl(params);

      expect(SlugRepository.findSlugBySlug).toHaveBeenCalledWith('nonexistentslug');
      expect(result).toEqual(notFoundUrl);
    });
  });

  describe('getUserSlugs', () => {
    it('should return all slugs for a user', async () => {
      const params = { user: mockUser };
      const slugs = [
        { id: '1', slug: 'slug1', url: 'https://example1.com', userId: mockUser.id },
        { id: '2', slug: 'slug2', url: 'https://example2.com', userId: mockUser.id },
      ];

      (SlugRepository.findSlugsByUserId as jest.Mock).mockResolvedValue(slugs);

      const result = await slugsService.getUserSlugs(params);

      expect(SlugRepository.findSlugsByUserId).toHaveBeenCalledWith(mockUser.id);
      expect(result).toEqual(slugs);
    });
  });

  describe('updateSlug', () => {
    it('should update a slug if the new slug does not already exist', async () => {
      const params = { slug: 'oldslug', newSlug: 'newslug', user: mockUser };

      (SlugRepository.findSlugBySlug as jest.Mock).mockResolvedValue(null);
      (SlugRepository.updateSlug as jest.Mock).mockResolvedValue([1]);

      await slugsService.updateSlug(params);

      expect(SlugRepository.findSlugBySlug).toHaveBeenCalledWith('newslug');
      expect(SlugRepository.updateSlug).toHaveBeenCalledWith('oldslug', 'newslug');
    });

    it('should throw an error if the new slug already exists', async () => {
      const params = { slug: 'oldslug', newSlug: 'existingslug', user: mockUser };

      (SlugRepository.findSlugBySlug as jest.Mock).mockResolvedValue({ slug: 'existingslug' });

      await expect(slugsService.updateSlug(params)).rejects.toThrow(UnprocessableEntityError);
    });
  });

  describe('deleteSlug', () => {
    it('should delete a slug and return the number of rows deleted', async () => {
      const params = { slug: 'shortslug', user: mockUser };
      (SlugRepository.deleteSlug as jest.Mock).mockResolvedValue(1);

      const result = await slugsService.deleteSlug(params);

      expect(SlugRepository.deleteSlug).toHaveBeenCalledWith('shortslug');
      expect(result).toEqual(1);
    });
  });
});
